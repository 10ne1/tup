
<p>Also note that there is a Makefile in the top-level directory. This file would typically have a target to call <em>make</em> in each of its subdirectories. The subdirectory Makefile could then build a piece of the project, and/or invoke make on its subdirectories. Because make is recursively invoking itself, this structure is known as "Recursive Make". This is generally considered a bad idea, because it leads to incorrect builds, maintenance hassles, and doesn't allow project-level build parallelism. For a more detailed analysis of why a recursive make is not a valid solution, see <a href="http://miller.emu.id.au/pmiller/books/rmch/">Recursive Make Considered Harmful</a>.

<p>The way to work around the inefficiencies and incorrect builds of recursive make is to implement a non-recursive make. A non-recursive make uses a single <em>make</em> process that has global dependency knowledge. Sub-projects can still specify their own dependencies (avoiding a single huge Makefile at the top level) by using GNU make's <em>include</em> directive. The single <em>make</em> process in the non-recursive make builds a DAG for the entire project and can use that knowledge to execute a parallel build across the whole project. It can also enforce dependencies across sibling directories that may have gotten lost or been incorrect in the recursive make setup.</p>
<p>Unfortunately, the non-recursive make, much like the recursive make, does not scale well. Consider a larger project, which now contains several other executables in addition to the main/lib combination from before:</p>

<p>After each change, <em>make</em> is run from the top-level. This Makefile iteratively includes each sub-makefile, including those in the irrelevant <em>exeN</em> directories (which, while not shown here, could be potentially large projects in of themselves). Each time <em>make</em> will read in every Makefile and every .d file in the entire project before narrowing down to the changes in main/ and lib/. A developer interested in saving time may instead try to execute make once in lib/ and once in main/, essentially keeping track of the <em>main-&gt;lib.a</em> dependency in his head. However, in this case he would be neglecting the fact that now exe1 also uses the library, so it needs to be re-built to make sure it hasn't been broken. Essentially the problem is that make needs to run at the top-level to ensure a consistent build, but for a large-scale project it is too slow to read in all the dependency information, and then <em>stat()</em> every file to determine which ones are out-of-date.</p>
