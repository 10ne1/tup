Mike Shal
G00525799
CS540 Assignment #3
2006/11/08

Files:
 README
 Makefile
 parser.y
 scanner.l

I believe I have implemented the parser to check for all semantic errors listed
in the assignment. When I first implemented the grammar and token language,
yacc reported several shift/reduce and reduce/reduce errors. After playing
around with the grammar a bit, I realized this was due to the fact that I was
returning all keywords as the token KEYWORD, and then using strcmp to verify
that the correct keyword was received at the appropriate places.  Instead it
turned out to be much easier if I made each keyword a separate token. Eg:
instead of copying out the text "break" and returning KEYWORD, I instead just
return BREAK and don't need to copy the text at all. This removed all of the
shift/reduce and reduce/reduce errors that were reported by yacc.

Another change I made to the grammar was separating all of the single-character
symbols from the multi-character symbols. I did this because yacc made allows
matching single characters by just typing them directly with single quotes. I
also separated the condition operators from the comparison operators since they
are used in different productions. This made the input language much easier to
implement.

Most of the productions were fairly easy to implement. In some cases I was able
to use the $$ syntax of yacc to bubble up information in the productions. For
example, I used a num_params field to keep track of the number of parameters
used in function calls and function declarations. This is passed up from the
non_empty_list to the parameter_list and eventually to the func_decl, where it
can be added to the function's type description.

In other cases I was not able to use the $$ syntax, but instead had to rely on
global variables to check for semantic errors. An example of this is making
sure a break statement occurs only within a while loop. Here I had to use the
scanner to increment a counter every time a WHILE token is found. Then in the
parser I decrement the counter every time the while_statement production is
used. Then when a break statement is found, I check if the counter is non-zero
- if so, then this statement is in a while loop. If it is zero, then I display
the error.

The symbol table is the only other main piece of the global data. Here I used a
'symtab' structure, which contains a linked list of symbols in a particular
scope. The whole symbol table is composed of a linked list of 'symtab'
structures, each with a different scope. Then to resolve a symbol, I go through
the list of symbols for each symtab until a match is found. Removing a scope is
quite simple using this data structure, because I can just point the symbol
table to the next symtab structure (since the most recent symtab scope is in
the front of the list).
