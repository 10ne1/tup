add in test case projects, analysis of make/ant
real-world times?

only add created monitor files to the create list if 'name' doesn't already exist?

any way to wrap make so that all sub-procs are wrapped?

 slab: use a free hunk (unlinked memory array), and a free list (object freed is put in the free list)
	alloc can get one from free list if available, if not then free hunk, and if not there then allocate another slab

wrapper fails if monitor is not running - always create object directory? what about if wrapper and monitor try to create at the same time?
 - actually, with create logic in place, wrapper fails if output fails do not match expected outputs given during the create phase. Still, same applies - always create objects in wrapper?

 modify 'tup graph' to be able to take in start node ids, to trim output

 compare open/mmap to open/read/malloc?

put configuration options in .tup/config or something. would be nice to do 'tup cfg' to see what the config is, or 'tup cfg keepgoing=1' to always run tup in 'keep going' mode. when changing cfg, print new config with keepgoing in green, or something, if it changed

options/features:
 - progress bar
 - color output
 - keep going
 - parallel

portability:
 mac osx may have trouble with unlink() inside a flist_foreach()?

when making a better 'tup' wrapper, be sure to call find_tup_dir, getexecwd(), and the confg init thing, except in the 'tup init' case.

support for test automation? (eg: when a program is rebuilt, its test are executed, or something)

tup:
 generate multiple files
 eg:
  foo -> a, b
  now:
  foo -> a, c
  must modify, a, delete b, create/modify c?
 if monitor is not used (eg: modify touch to do a 'tup touch foo.c' as well) -
  when rebuilding foo.c, should stat foo.h and compare against .tup/objects/foo.h/.name to see if timestamp is different? maybe have a timestamp option (part of the tup configuration) to perform this check, and if out of date add foo.h to modify list as well. That way if foo.h is modified but 'tup touch foo.h' wasn't executed, the build won't be inconsistent.

test:
 make sure when a directory is deleted (eg: rm -rf bar), then the 'bar' directory object is deleted after update
