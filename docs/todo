FD_CLOEXEC flag on file descriptors?

find a way to avoid committing after the parsing/delete stage

let partial parsings commit rather than waiting for all directories to finish successfully

can we have the monitor kill the updater if a file modification is detected? or restart it?
 - also what happens if there is no monitor? will the next update work properly?

will cp -Rp olddir newdir break everything if olddir already has a bunch of stuff compiled in it? - try --seriously-overwrite-outputfiles flag again? I forget why I didn't finish that.

instead of keeping both files and commands in delete list, put them in separate lists. Make the command thing just a progress bar.

autoupdate doesn't autoupdate when first starting the monitor if files have changed while tup wasn't watching

put dirtree in a list for things like tup_db_select_node_by_flags to avoid callback?

don't continue down re-parse tree unless outputs of the dir have changed.

give user an option to kill an autoupdate updater

progress bar looks dumb when you have numbers in the thousands because of the space between the second number and the ']', and then another space before the program

tup 'next_dirs' - print out other directories that use files in the current dir?

name_list_entry - pointer to tup_entry?

syntax: color %flags in output

limit variable names: eg: 0-9a-zA-Z_-

when you include a generated file, print path relative to command that was executed? eg: foo/bar.c includes ../blah/baz.c, print it out as ../blah/baz.c

move kconfig into tup?

tup show to list the Tupfile as read in the current dir?

read in +/- in order to add/remove worker threads?

rule without a : should be an error?

reverse of tup graph: give it a file, print the dir/command to create it?

autoupdate doesn't do everything in tup_init() - is find_tup_dir() needed? what   about db open?

sqlite style graphs for parser

indent dependent dirs while parsing?

cache flags and write out the diff before a commit? eg: no need to add a command to modify (in order to pick up where we left off), then remove it a second later when the command executes.

replace 'tup monitor' with a tup.sh function and wrap it with valgrind

monitor should move deleted files to use dir=-1 instead of actually doing the full node deletion. The full deletion is done at next tup upd. file should be renamed to avoid unique constraint violation (name=tupid?)

get rid of 'Already parsed' messages - indent instead

rm file, re-create as dir without monitor running

look at gcov, gperf

highlight += differently from = to make it obvious when a var is overridden

spaces in filenames and/or directories?

make all error messages and such pretty print on things other than 80 columns

make 'tup graph .gitignore' or 'tup graph .git/refs/foo' have a better error message
 - I was trying to do 'find . -type f | xargs tup graph' to just show files

use auto-unmount for fuse?

fuse monitor - open fd to access underlying filesystem (overlay fs). Maybe fuse server can use fd to by-pass monitor when doing its writes? That way fuse monitor can always watch filesystem even during a build?

make colors a config option, rather than a compile time thing

create 'a' and 'b' with the same timestamps. move 'b' -> 'c', 'a' -> 'b', and 'b' is not rebuilt - timestamp problem
 - add inode to node table?

output files to a directory other than the current one?

runscr: error message in parser about including generated Tupfiles: suggest using runscr instead

runscr: Supports multi-outputs? eg: javac with inner classes

runscr branch - need to wrap opendir/readdir to give generated files before they are created? Or else scripts won't wildcard properly?
 - test: generate *.o in a sub/Tupfile, then use a python script in ./Tupfile to link sub/*.o - make sure ./Tupfile is run first (it should stop running and run sub/Tupfile once it opendirs() on sub/, then readdir() should include the generated list)

after runscr: remove *-chain, <| rules

avoid Scanning filesystem... tup warning blah problem

print times before each [ tup ] line?

when doing 'touch foo' without '|> foo', why is it a different error message when 'foo' is already a node or not? (ie: if foo is a ghost, or something)

add Kconfig file

windows builds: Add a 'release' directory for new tags, and an 'experimental' directory for whenever a new set of commits is pushed.

gentoo ebuild

debian/ubuntu package

use setsid() in monitor daemonize (or use daemon(3))

add 'ls' command to show generated files and such in different colors?

test suite: (bootstrap + tup) linux, linux64, solaris, mac osx, win, test with bash and dash as symlinks for /bin/sh

separate link table for parser? eg: instead of 'select to_id from link where from_id=? and to_id blah type=TUP_NODE_DIR', maybe we can do 'select to_id from parser_link where from_id=?'

use 'cmdid' field instead of a link to point to outputs?

should TUP_PLATFORM be a $-variable instead of an @-variable? ie: Does it make sense to be able to override it in tup.config, or should it always be static?

use _root for tree roots, and _tree for the structures in the tree

buffered output (anatol/buff*)

use lemon to generate a parser?
 - could also use grammar file to generate syntax file per http://code.google.com/p/autohighlight/

tup web: examples: change codec in mplayer / upgrade firefox
tup web: compare parallelism in make to tup

build variants
 - default variant has empty tup.config to enforce a standard configuration?
 - or allow to disable default variant for out-of-source only build?
 - allow variants to interact? Or would this force users to have certain variants installed? eg: Rule that has debug/foo.exe and release/foo.exe as inputs is allowed or not?
 - can variants have configs checked in?

html:
  proof: no clean target
  graphs
   - re-use tup_dag_*.png and partial_dag_*.png
   - link styles
  when Tupfiles are parsed
  supported tools / how to use things like ar and ln
  files outside of tup are ignored
   - hidden files can be written to for testing (result in warnings)
   - hidden files cannot be read from
  how files are deleted
  how dependencies are described/discovered
  man pages: tup command line, tup_api
  error messages (eg: you get this error message if...)
  document !macro.c !macro.o
  wc3 validate tup webpages
  should be able to checkout, tup init, tup upd
   - or checkout the project as a subdirectory: tup init at a higher level, tup upd
