<p>There are 3 kinds of variables in tup. There is $, %, and @. For nethack fans, you will notice this corresponds to money, food, and the Wizard of Yendor. I don't need to tell you which is the most dangerous.</p>

<h1>$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$</h1>
<p>The $ variables work kind of like they do in make, only they are severely more limited. This is somewhat on purpose, so you can't make silly and unreadable Tupfiles. Also, I'm lazy. They are valid within a Tupfile, and aren't magically set from the environment. You would use these if you don't want to retype some long string in a Tupfile (like a list of source files, or something). For example:</p>
<pre>
srcs = foo.c
srcs += bar.c ok.c
cc = gcc
: foreach $(srcs) |&gt; $(cc) -c %f -o %o |&gt; %F.o
</pre>
<p>Don't try to do anything crazy like:</p>
<ul>
  <li>nest them: $(compiler_$(opts))</li>
  <li>pass them in from the environment: tup upd CFLAGS=-foo</li>
  <li>use deferred expansion. All variables are expanded when the line is parsed.</li>
</ul>
<p>If you do any of those things you will be considered crazy and met with frowny faces.</p>

<h1>%%%%%%%%%%%%%%%%%%%%%%</h1>
<p>The % variables are similar to the special $^, $&lt;, or $whatevs variables in make. They only make sense in the command (the stuff between the two |&gt; markers), and, except for %o, in the output list (the part after the second |&gt;). Break it down:</p>
<table border=1>
 <tr><td><b>Flag</b></td><td>What it be</td></tr>
 <tr><td>%f</b></td><td>The filename</td></tr>
 <tr><td>%F</b></td><td>The filename without the extension (the last '.' and everything after it are removed)</td></tr>
 <tr><td>%b</b></td><td>The basename (only includes everything after the last '/')</td></tr>
 <tr><td>%B</b></td><td>The basename without the extension (err...yeah)</td></tr>
 <tr><td>%o</b></td><td>Copies whatever is in the output field. This is just for convenience in the command string.</td></tr>
</table>
<p>Let's play pretend! Say I want to compile two C files from a src/ directory and then link them. Here's how the % things would work out:</p>
<pre>
$ ls
Tupfile    src/
$ cat Tupfile
: foreach src/*.c |&gt; gcc -c %f -o %o |&gt; %B.o
: *.o |&gt; gcc %f -o %o |&gt; hello_world
$ ls src/
foo.c      bar.c
</pre>
<p>The first rule (the foreach one) would be parsed twice. The first time the flags would be set like so:</p>
<table border=1>
 <tr><td>%f</b></td><td>src/foo.c</td></tr>
 <tr><td>%F</b></td><td>src/foo</td></tr>
 <tr><td>%b</b></td><td>foo.c</td></tr>
 <tr><td>%B</b></td><td>foo</td></tr>
</table>
<p>Then it would be parsed again for bar.c:</p>
<table border=1>
 <tr><td>%f</b></td><td>src/bar.c</td></tr>
 <tr><td>%F</b></td><td>src/bar</td></tr>
 <tr><td>%b</b></td><td>bar.c</td></tr>
 <tr><td>%B</b></td><td>bar</td></tr>
</table>
<p>Then we can parse the second rule. Since it is not a foreach rule, the % variables contain the entire input list:</p>
<table border=1>
 <tr><td>%f</b></td><td>src/foo.c src/bar.c</td></tr>
 <tr><td>%F</b></td><td>src/bar src/bar</td></tr>
 <tr><td>%b</b></td><td>foo.c bar.c</td></tr>
 <tr><td>%B</b></td><td>foo bar</td></tr>
</table>
<p>After you run update you would get this:</p>
<pre>
$ ls
Tupfile    foo.o      bar.o      hello_world      src/
</pre>

<h1>@@@@@@@@@@@@@@@@@@@@@@</h1>
<p>The @ variables are super special - they actually appear in the DAG. You use them by doing something like @(FOO). By appearing in the DAG, if you change the variable, any Tupfiles that use them will be re-parsed. Also, you can use a special sed rule to convert an input file that has @FOO@ references and replaces them with their values in the output file. You would want to use these for any global configuration options in your program. One way you could use them is to enable or disable rules based on their value:</p>
<pre>
ifeq (@(NCURSES),y)
: foreach blah blah blah
endif
</pre>
<p>If @(NCURSES) is set to y, then those rules take effect. If we later change @(NCURSES) to n, then this Tupfile will be parsed again during the update, and those rules will be deleted.</p>
<p>Using them in a sed rule is pretty easy too. You could make a file like so:</p>
<pre>
$ cat Tupfile
, foo.h.in |&gt; foo.h
$ cat foo.h.in
#define SPEED @SPEED@
</pre>
<p>Assuming there is a variable called @(SPEED) and it's set to "fast", then when we update you would get:</p>
<pre>
$ cat foo.h
#define SPEED "fast"
</pre>
<p>If we then change @(SPEED) to "super fast", foo.h would be re-generated with the new value. Of course, since this is tup, the file would be re-generated at ludicrous speed, no matter what the variable @(SPEED) is set to.</p>
